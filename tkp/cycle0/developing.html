

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Guidelines for Developers &mdash; LOFAR Transients Tools Release 0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     'Release 0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="LOFAR Transients Tools Release 0 documentation" href="index.html" />
    <link rel="next" title="Standalone Tools" href="tools/index.html" />
    <link rel="prev" title="LOFAR Transients Tools" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tools/index.html" title="Standalone Tools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="LOFAR Transients Tools"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">LOFAR Transients Tools Release 0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="guidelines-for-developers">
<span id="developing"></span><h1>Guidelines for Developers<a class="headerlink" href="#guidelines-for-developers" title="Permalink to this headline">¶</a></h1>
<p>This documents deals (shortly) with writing software for the
Transients Pipeline, either the TraP part (recipes) or the underlying
modules (the TKP package).</p>
<div class="section" id="trap">
<h2>TraP<a class="headerlink" href="#trap" title="Permalink to this headline">¶</a></h2>
<p>The Transients Pipeline is formed by a set of master-node recipes
within the standard pipeline framework. Each master recipe is in
essence a single step in the pipeline (though occasionally, steps will
be combined), and may or may not drive a set of distributed compute
node recipes. Master recipes derive from a
<tt class="xref py py-class docutils literal"><span class="pre">lofarpipe.support.baserecipe.BaseRecipe</span></tt>, and when a master
recipe needs to start up compute node recipes, from
<tt class="xref py py-class docutils literal"><span class="pre">lofarpipe.support.remotecommand.RemoteCommandRecipeMixIn</span></tt> as
well. Compute node recipes generally are derived from
<tt class="xref py py-class docutils literal"><span class="pre">lofarpipe.support.lofarnode.LOFARnodeTCP</span></tt>. The master recipes
know how to import the compute node recipes from the logic that the
node recipes live in the <tt class="file docutils literal"><span class="pre">../nodes/</span></tt> subdirectory with the same
name as the master recipe (the master recipe lives, of course, in the
<tt class="file docutils literal"><span class="pre">../master/</span></tt> subdirectory.</p>
<p>The inputs (parameters) and outputs (results; return values) of the
master recipe are given by two class variables, and are used in the
main <cite>go</cite> method. Normally, the <cite>go</cite> method is the only method that
needs to be overridden in the derived master recipe. Inputs can be
given when calling the recipe, often from another (main) recipe, using
the <cite>run_task</cite> method; the outputs are returned as a dictionary from
the same <cite>run_task</cite> method. Note that the recipes themselves should
always return 0 on success and non-0 on failure.</p>
<p>The node recipes are simpler. They don&#8217;t require inputs and outputs to
be defined and just take their arguments in the <cite>run</cite> method, which is
the method to be overridden from the base node recipe (eg,
<tt class="xref py py-class docutils literal"><span class="pre">LOFARnodeTCP</span></tt>). The return value is again 0 or non-0; the
actual results are stored in the <cite>outputs</cite> attribute.</p>
<p>The node recipes are called from the master recipe using the
<tt class="xref py py-class docutils literal"><span class="pre">ComputeJob</span></tt> class. This sets up the call to the node recipe
with the correct argument, and includes the compute node this recipe
will be run on. A list of compute nodes is obtained from the cluster
description file, and iterating through them, one creates several
<tt class="xref py py-class docutils literal"><span class="pre">ComputeJob</span></tt> instances, which are then scheduled and run.</p>
<p>A simplified example (from the classification recipe) looks as follows
(note that the import statements are not shown, nor are the inputs and
outputs definitions):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">classification</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">go</span><span class="p">()</span>
    <span class="c"># Obtain the available compute nodes</span>
    <span class="n">clusterdesc</span> <span class="o">=</span> <span class="n">ClusterDesc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;cluster&#39;</span><span class="p">,</span> <span class="s">&quot;clusterdesc&quot;</span><span class="p">))</span>
    <span class="n">available_nodes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">clusterdesc</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">get_compute_nodes</span><span class="p">(</span><span class="n">clusterdesc</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">available_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="c"># Set up the command to be run on the compute nodes, as a python script over ssh</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s">&quot;python </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__file__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;master&#39;</span><span class="p">,</span> <span class="s">&#39;nodes&#39;</span><span class="p">)</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">transient</span> <span class="ow">in</span> <span class="n">transients</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Executing classification for </span><span class="si">%s</span><span class="s"> on node </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">transient</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
        <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="c"># Create a compute job, on this node with the given command and list of arguments</span>
            <span class="n">ComputeJob</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s">&#39;schema&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;layout&quot;</span><span class="p">,</span> <span class="s">&quot;parset_directory&quot;</span><span class="p">),</span>
            <span class="n">transient</span><span class="p">,</span> <span class="n">weight_cutoff</span><span class="p">,</span> <span class="n">tkp</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">CONFIGDIR</span><span class="p">]))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Scheduling jobs&quot;</span><span class="p">)</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schedule_jobs</span><span class="p">(</span><span class="n">jobs</span><span class="p">,</span> <span class="n">max_per_node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s">&#39;nproc&#39;</span><span class="p">])</span>  <span class="c"># nproc limits the maximum amount of CPU allowed to be used</span>
    <span class="c"># Get the results</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="s">&#39;transients&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">job</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s">&#39;transient&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()]</span>
    <span class="c"># Check if we got any error from running the jobs</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">isSet</span><span class="p">():</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Keep in mind that a master recipe does not have to call a compute node
recipe (which then eliminates all of the above code). For example, the
<a class="reference external" href="http://docs.transientskp.org/trap/cycle0/recipes.html#transient-search-recipe" title="(in TRAP v1.0)"><em class="xref std std-ref">transient search</em></a> recipe consists
only of a master recipe: any computational intensive work is actually
done inside the database, and the overhead of starting up a compute
node to interact with the database is probably more than calling the
database directly from the master (front end) node.</p>
<p>A note on database connections: these cannot be transferred from the
master to the node recipes (cannot be pickled, and thus cannot be
transferred across the ssh connection), so each compute node has to
open its own database connection, and close it again. The most obvious
way (if the TKP configuration file is configured correctly) is simply
done on the compute nodes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">log_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">DataBase</span><span class="p">())</span> <span class="k">as</span> <span class="n">database</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="tkp">
<h2>TKP<a class="headerlink" href="#tkp" title="Permalink to this headline">¶</a></h2>
<p>The TKP package is a set of modules (or actually modules within four
subpackages) that implement the algorithms used by the transients
pipeline. The subpackages are:</p>
<ul class="simple">
<li>database</li>
<li>sourcefinder</li>
<li>classification</li>
<li>utility</li>
</ul>
<p>The names of the subpackages should speak for themselves; utility is
more or less a collection of code that does not really fit anywhere
else, or ties a few subpackages together (such as the database and
sourcefinder).</p>
<p>The main thing to keep in mind when writing (new) code is that the
subpackages are, as much as possible, independent of each other. There
are some minor dependencies still among the packages, but these will
hopefully be removed in the future. Other than that, the individual
module names should give one a good idea what code to put where. An
overview of the most used modules and a short description of their
task follows:</p>
<ul class="simple">
<li>database<ul>
<li>database: take care of database connection</li>
<li>dataset: mini-ORM to some database tables</li>
<li>utils: all the SQL queries inside their respective Python functions</li>
</ul>
</li>
<li>sourcefinder<ul>
<li>image: image (data) handling through the Image class</li>
<li>extract: source extraction routines</li>
<li>fitting: actual source fitting routines</li>
<li>gaussian: 2D gaussian function</li>
<li>stats: specific statistic routines</li>
<li>utils: some sourcefinder specific utilities</li>
</ul>
</li>
<li>classification<ul>
<li>manual: subpackage for manual classification<ul>
<li>transient: define transient class</li>
<li>classifier: classifier routines</li>
<li>classification: defines the classification (decision tree); can be user overriden</li>
<li>utils: utility classes for the transient class</li>
</ul>
</li>
<li>features: feature detection subpackage<ul>
<li>lightcurve: obtain characteristics of the transient light curve</li>
<li>catalog: catalog (position) matching routines</li>
<li>sql: SQL routines (to be integrated into the lightcurve module)</li>
</ul>
</li>
</ul>
</li>
<li>utility:<ul>
<li>accessors: (Image) data file handling classes</li>
<li>containers: classes for handling the sourcefinder results</li>
<li>coordinates: various coordinate handling routines, and WCS class</li>
<li>fits: few routines to handle MS to FITS metadata and combination (stacking) of FITS files</li>
<li>memoize: decorator to cache results of methods</li>
<li>sigmaclip: generic kapp, sigma clipping routine (used by classification.features)</li>
<li>uncertain: Uncertainty class that can hold a value plus its errors</li>
<li>exceptions: a few (rarely used) TKP exception classes</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="builds">
<h2>Builds<a class="headerlink" href="#builds" title="Permalink to this headline">¶</a></h2>
<p>The installation procedure is described in <a class="reference external" href="http://docs.transientskp.org/trap/cycle0/installation.html#installation" title="(in TRAP v1.0)"><em class="xref std std-ref">the TRAP installation
documentation</em></a>. This section summarizes the nightly build
procedure on the <tt class="docutils literal"><span class="pre">heastro</span></tt> system in Amsterdam.</p>
<p>A build is performed at 04:30 every morning. This build is currently performed
by the script <tt class="docutils literal"><span class="pre">/zfs/heastro-plex/scratch/swinbank/build/build-tkp.sh</span></tt>. It
builds and installs the HEAD of the <tt class="docutils literal"><span class="pre">master</span></tt> branch of both the
<a class="reference external" href="https://github.com/transientskp/tkp/">transientskp/tkp</a> and
<a class="reference external" href="https://github.com/transientskp/trap">transientskp/trap</a> repositories.
Files are installed under <tt class="docutils literal"><span class="pre">/opt/tkp/${BUILD_DATE}</span></tt> and, after successful
installation, the symlink <tt class="docutils literal"><span class="pre">/opt/tkp/latest</span></tt> is pointed at that location.
Thus, end-users can always access the latest successful build as
<tt class="docutils literal"><span class="pre">/opt/tkp/latest/</span></tt>.</p>
<p>The file <tt class="docutils literal"><span class="pre">/opt/tkp/init.sh</span></tt> may be sourced (ie, run <tt class="docutils literal"><span class="pre">.</span> <span class="pre">/opt/tkp/init.sh</span></tt>
at your prompt) by <tt class="docutils literal"><span class="pre">bash</span></tt> shell users to set all the necessary environment
variables to run the TKP code.</p>
<p>Logs of all build attempts are available under <tt class="docutils literal"><span class="pre">/opt/tkp/logs</span></tt>.</p>
</div>
<div class="section" id="coding-guidelines">
<h2>Coding guidelines<a class="headerlink" href="#coding-guidelines" title="Permalink to this headline">¶</a></h2>
<p>We try to follow PEP 8 as much as possible, although at times, this is
flexible (e.g., short variable names sometimes make more sense in the
context; and there is no hard rule where braces or parentheses should
go when they cover more than one line).</p>
<p>Occasionally, it may be useful to run pylint (or similar) on the code,
to pick out a few things (unused variables and such). Don&#8217;t aim to get
a 10/10 score, just use the suggestions by pylint where deemed
applicable.</p>
</div>
<div class="section" id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<p>All documentation in the <cite>code</cite> part of the TKP repository is written
in restructured text, whether doc strings or longer documents, and is
then put together and transformed using Sphinx. By &#8216;put together&#8217;, we
mean that Sphinx will pick up the doc strings from referenced modules
and add this to the other documentation; by transformed we mean the
Sphinx will create HTML pages out of the documentation. The latter is
done on a nightly basis, so that documentation is refreshed over
night.</p>
<p>There currently exists two main sections of documentation:</p>
<ul class="simple">
<li>TraP: this section deals with setting up and running the transients
pipeline, as well as more details about the individual recipes.</li>
<li>TKP: this section deals with the underlying modules and algorithms
used in the transients pipeline.</li>
</ul>
<p>Using the intersphinx extension, links can be and are created between
the two documentation sections.</p>
<div class="section" id="doc-strings">
<h3>Doc strings<a class="headerlink" href="#doc-strings" title="Permalink to this headline">¶</a></h3>
<p>The doc strings also follow pretty much the suggestions in PEP 8. They
are relatively relaxed, and not all methods will have a proper
docstring. The documentation of the arguments and keyword arguments
follow roughly the convention suggested <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html?showone=Comments#Comments">by Google</a>
(<a class="reference external" href="http://packages.python.org/an_example_pypi_project/sphinx.html#function-definitions">see also</a>);
this is different than the <a class="reference external" href="http://sphinx.pocoo.org/markup/desc.html#info-field-lists">Sphinx supported style</a>, but
feels more readable.</p>
</div>
</div>
<div class="section" id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>No (good) piece of software can be without proper tests. In the case
of the TKP library, a (presumably) most tests have come after the fact
(i.e., first the problem was solved, then it was tested if that really
worked properly), and often tests were initially practical use cases,
and not so much stylized unit tests.</p>
<p>As a result, there are probably still many routines that lack proper
unit tests, although more unit tests are still being added.</p>
<p>I suggest to follow at least one simple rule:</p>
<blockquote class="pull-quote">
<div><strong>If a bug shows up and is fixed, or a function is changed, write a
unit test, detailing the bug (and its fix) or the change.</strong></div></blockquote>
<div class="section" id="unit-tests">
<h3>Unit tests<a class="headerlink" href="#unit-tests" title="Permalink to this headline">¶</a></h3>
<p>The unit tests use the <tt class="xref py py-mod docutils literal"><span class="pre">unittest2</span></tt> module. For Python 2.7, this
is the built-in <a class="reference external" href="http://docs.python.org/library/unittest.html#unittest" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">unittest</span></tt></a> module, but for earlier versions, the
module needs to be installed separately. The unit tests have the
following check at the import level for this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="o">.</span><span class="n">assertIsInstance</span>
<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">unittest2</span> <span class="kn">as</span> <span class="nn">unittest</span>
</pre></div>
</div>
</div>
<div class="section" id="running-the-unit-tests">
<h3>Running the unit tests<a class="headerlink" href="#running-the-unit-tests" title="Permalink to this headline">¶</a></h3>
<p>To run the unit tests, there exists a test subdirectory outside of the
TKP package (at <tt class="file docutils literal"><span class="pre">tkp/trunk/tests</span></tt>). The <tt class="file docutils literal"><span class="pre">runtests.bash</span></tt>
script sets up the necessary paths and allows to call the various unit
tests as an argument to the script. In the end, this was done to
<cite>ctest</cite> can automatically run each unit test as a separate test (the
various path settings inside the script are optimized for in-build
testing with cmake and ctest).</p>
<p>To run all the tests at once, one can also use the <tt class="file docutils literal"><span class="pre">test.py</span></tt>
script, provided all the paths are set correctly.</p>
</div>
<div class="section" id="pipeline-tests">
<h3>Pipeline tests<a class="headerlink" href="#pipeline-tests" title="Permalink to this headline">¶</a></h3>
<p>Ultimately, the only way to know if everything works correctly (or as
correct as can be deduced), is by running the transients
pipeline. Work is still in progress to set up a set of simulated data
that will test the various aspects of the pipeline, including proper
source finding, association and classification, even under rare (bad),
but controlled (simulated) circumstances.</p>
<p>For now, I would suggest to have a look at
<tt class="file docutils literal"><span class="pre">/home/evert/work/trap/jobs/bell/control/runtrap.sh</span></tt>, and work
back from this file for the necessary setup. I have been using this
(small) dataset to at least test the basic functionality of the
transients pipeline. Practically, running these data through the
pipeline should produce about five transients (although none of them
are real: they are just artefacts of, liekely, flux calibration
problems).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Guidelines for Developers</a><ul>
<li><a class="reference internal" href="#trap">TraP</a></li>
<li><a class="reference internal" href="#tkp">TKP</a></li>
<li><a class="reference internal" href="#builds">Builds</a></li>
<li><a class="reference internal" href="#coding-guidelines">Coding guidelines</a></li>
<li><a class="reference internal" href="#documentation">Documentation</a><ul>
<li><a class="reference internal" href="#doc-strings">Doc strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing">Testing</a><ul>
<li><a class="reference internal" href="#unit-tests">Unit tests</a></li>
<li><a class="reference internal" href="#running-the-unit-tests">Running the unit tests</a></li>
<li><a class="reference internal" href="#pipeline-tests">Pipeline tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">LOFAR Transients Tools</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tools/index.html"
                        title="next chapter">Standalone Tools</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/developing.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tools/index.html" title="Standalone Tools"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="LOFAR Transients Tools"
             >previous</a> |</li>
        <li><a href="index.html">LOFAR Transients Tools Release 0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, LOFAR Transients Key Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>