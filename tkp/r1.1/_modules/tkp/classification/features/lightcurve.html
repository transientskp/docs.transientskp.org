<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tkp.classification.features.lightcurve &mdash; LOFAR Transients Pipeline 1.1 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/lofar.ico"/>
    <link rel="top" title="LOFAR Transients Pipeline 1.1 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">LOFAR Transients Pipeline 1.1 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for tkp.classification.features.lightcurve</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">.. module:: lightcurve</span>

<span class="sd">:synopsis: Obtain light curve characteristics of a transient source</span>

<span class="sd">.. moduleauthor: Evert Rol, Transient Key Project &lt;discovery@transientskp.org&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c">#import pygsl.statistics</span>

<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">tkp.utility.sigmaclip</span> <span class="kn">import</span> <span class="n">calcsigma</span>
<span class="kn">from</span> <span class="nn">tkp.classification.transient.utils</span> <span class="kn">import</span> <span class="n">DateTime</span>
<span class="kn">from</span> <span class="nn">.sql</span> <span class="kn">import</span> <span class="n">lightcurve</span> <span class="k">as</span> <span class="n">sql_lightcurve</span>


<span class="n">SECONDS_IN_DAY</span> <span class="o">=</span> <span class="mf">86400.</span>

<div class="viewcode-block" id="LightCurve"><a class="viewcode-back" href="../../../../devref/tkp/classification/features/lightcurve.html#tkp.classification.features.lightcurve.LightCurve">[docs]</a><span class="k">class</span> <span class="nc">LightCurve</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple class that holds a light curve by means of several numpy</span>
<span class="sd">    arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="LightCurve.from_database"><a class="viewcode-back" href="../../../../devref/tkp/classification/features/lightcurve.html#tkp.classification.features.lightcurve.LightCurve.from_database">[docs]</a>    <span class="k">def</span> <span class="nf">from_database</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">srcid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the complete light curve from the database</span>

<span class="sd">        Args:</span>

<span class="sd">            cursor: database cursor</span>

<span class="sd">            srcid (int): id of the source in the database</span>

<span class="sd">        Fills the attributes with data obtained from the</span>
<span class="sd">        database. Attributes of the class are the same as those for</span>
<span class="sd">        the constructor. In this case, the srcids attribute is always</span>
<span class="sd">        filled, and reflects the individual extracted sources.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; with closing(Database()) as database:</span>
<span class="sd">            ...     lightcurve = LightCurve.from_database(database.cursor, 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql_lightcurve</span><span class="p">,</span> <span class="n">srcid</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">LightCurve</span><span class="p">(</span>
            <span class="n">taustart_tss</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">tau_times</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">fluxes</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
            <span class="n">srcids</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taustart_tss</span><span class="p">,</span> <span class="n">tau_times</span><span class="p">,</span> <span class="n">fluxes</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">srcids</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stokes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">freq_central</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>

<span class="sd">            taustart_tss (list or array of datetime.datetime() instances):</span>
<span class="sd">            (mid) observing times</span>

<span class="sd">            tau_times (list or array of floats): integration times in seconds</span>

<span class="sd">            fluxes (list or array of floats): flux levels in Janskys</span>

<span class="sd">            errors (list or array of floats): flux errors in Janskys</span>

<span class="sd">            srcids (list or array of ints, None): database id of &#39;extracted</span>
<span class="sd">            source&#39; for each data point. If left to the default of None, this</span>
<span class="sd">            is ignored.</span>

<span class="sd">            bands (list or array of ints, None): frequency band ID&#39;s</span>

<span class="sd">            stokes (list or array of ints, None): stokes</span>

<span class="sd">        Raises:</span>

<span class="sd">            - ValueError: when input arguments are not equal length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">taustart_tss</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tau_times</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fluxes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">srcids</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">srcids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">srcids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">srcids</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">)</span> <span class="o">==</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">srcids</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;light curve data arrays are not of equal length&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

<div class="viewcode-block" id="LightCurve.reset"><a class="viewcode-back" href="../../../../devref/tkp/classification/features/lightcurve.html#tkp.classification.features.lightcurve.LightCurve.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset all the extracted features to their default values</span>

<span class="sd">        The default values are generally numpy.nan or 0; using NaN</span>
<span class="sd">        often provides a better indication for other function or</span>
<span class="sd">        methods that the data does not exist.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;mean&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;sigma&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                           <span class="s">&#39;indices&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;start&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;end&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                         <span class="s">&#39;total&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;active&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxincrease</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;increase&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;absolute&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;relative&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">},</span>
                             <span class="s">&#39;peak&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;ipeak&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">risefall</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;rise&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;flux&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">},</span>
                         <span class="s">&#39;fall&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;flux&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">},</span>
                         <span class="s">&#39;ratio&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;max&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;mean&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;stddev&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                      <span class="s">&#39;skew&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="s">&#39;kurtosis&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">}</span>
</div>
<div class="viewcode-block" id="LightCurve.calc_background"><a class="viewcode-back" href="../../../../devref/tkp/classification/features/lightcurve.html#tkp.classification.features.lightcurve.LightCurve.calc_background">[docs]</a>    <span class="k">def</span> <span class="nf">calc_background</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">niter</span><span class="o">=-</span><span class="mi">50</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate background flux</span>

<span class="sd">        Kwargs:</span>

<span class="sd">            niter (int): number of iterations. Passed on to sigmaclip()</span>

<span class="sd">            kappa (2-tuple of floats): lower and upper kappa</span>
<span class="sd">                values. Passed on to sigmaclip()</span>

<span class="sd">        Returns:</span>

<span class="sd">            (dict): mean, sigma, indices</span>
<span class="sd">                where light curve is at background level (True) and where</span>
<span class="sd">                not (False).</span>

<span class="sd">        Uses sigmaclipping to estimate a background. This only works</span>
<span class="sd">        well when there are enough background points.</span>

<span class="sd">        Also estimates the first point in time where the light curve</span>
<span class="sd">        deviates from the background (T_zero), and the current duration</span>
<span class="sd">        where the light curve is above the background.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&#39;tkp&#39;</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">nniter</span> <span class="o">=</span> <span class="o">-</span><span class="n">niter</span> <span class="k">if</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">niter</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nniter</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
            <span class="c"># Get the sigma from the measured flux errors, instead of</span>
            <span class="c"># deriving it from the spread in values</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
            <span class="c"># Throw away all data that are kappa*sigma above the current</span>
            <span class="c"># background value</span>
            <span class="n">newindices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">+</span> <span class="n">kappa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">newindices</span> <span class="o">==</span> <span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c"># no change anymore</span>
                    <span class="k">break</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">newindices</span>

        <span class="c"># Now check if there are still data below the background</span>
        <span class="c"># Above, we have assumed most transients rise above the</span>
        <span class="c"># background, so we filter out increases in flux, not decreases</span>
        <span class="c"># We do that here now</span>
        <span class="c"># We can&#39;t do it at the same time as filtering the increase,</span>
        <span class="c"># because that may filter too much at one</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nniter</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
            <span class="c"># Get the sigma from the measured flux errors, instead of</span>
            <span class="c"># deriving it from the spread in values</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
            <span class="c"># Throw away all data that are kappa*sigma above the current</span>
            <span class="c"># background value</span>
            <span class="n">newindices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">&gt;</span> <span class="n">value</span> <span class="o">-</span> <span class="n">kappa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">niter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">newindices</span> <span class="o">==</span> <span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c"># no change anymore</span>
                    <span class="k">break</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">newindices</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">value</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">calcsigma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
            <span class="c"># Now that we have the proper background, recalculate the indices</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">&gt;</span> <span class="n">value</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">*</span><span class="n">kappa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">+</span> <span class="n">sigma</span><span class="o">*</span><span class="n">kappa</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span>

</div>
<div class="viewcode-block" id="LightCurve.calc_duration"><a class="viewcode-back" href="../../../../devref/tkp/classification/features/lightcurve.html#tkp.classification.features.lightcurve.LightCurve.calc_duration">[docs]</a>    <span class="k">def</span> <span class="nf">calc_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate duration and estimate start of the transient event</span>

<span class="sd">        Kwargs:</span>

<span class="sd">            indices (numpy.ndarray): None or a numpy.ndarray of</span>
<span class="sd">                relevant indices; that is, the indices for points</span>
<span class="sd">                where the light curve duration should be calculated.</span>

<span class="sd">        It calculates two durations:</span>

<span class="sd">        - full duration, from first rise above background until last bit</span>
<span class="sd">          above background. This is simply the end time - start time.</span>

<span class="sd">        - active duration, where any intermediate returns to the</span>
<span class="sd">          background level are ignored. This takes only the observed bins</span>
<span class="sd">          and multiplies those with their respective integration</span>
<span class="sd">          times. Any observations outside of any transient activity do not</span>
<span class="sd">          contribute to this value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">active</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calc_background</span><span class="p">()</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span><span class="p">[</span><span class="n">indices</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">[</span><span class="n">indices</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">day</span><span class="p">,</span>
                             <span class="n">hour</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span>
                             <span class="n">second</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span><span class="p">[</span><span class="n">indices</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">[</span><span class="n">indices</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">DateTime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">end</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="n">end</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="n">end</span><span class="o">.</span><span class="n">day</span><span class="p">,</span>
                           <span class="n">hour</span><span class="o">=</span><span class="n">end</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="n">end</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span>
                           <span class="n">second</span><span class="o">=</span><span class="n">end</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span><span class="o">.</span><span class="n">days</span> <span class="o">*</span> <span class="mf">86400.</span> <span class="o">+</span> <span class="n">duration</span><span class="o">.</span><span class="n">seconds</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">[</span><span class="n">indices</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">active</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c"># only background</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">active</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="s">&#39;start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="s">&#39;end&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="s">&#39;total&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="s">&#39;active&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">active</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span>

</div>
<div class="viewcode-block" id="LightCurve.calc_fluxincrease"><a class="viewcode-back" href="../../../../devref/tkp/classification/features/lightcurve.html#tkp.classification.features.lightcurve.LightCurve.calc_fluxincrease">[docs]</a>    <span class="k">def</span> <span class="nf">calc_fluxincrease</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the peak flux, its increase (absolute &amp; relative) and</span>
<span class="sd">        the peak index</span>

<span class="sd">        Kwargs:</span>

<span class="sd">            background (float): previously calculated background (or</span>
<span class="sd">                given by the user). If not given, the background is</span>
<span class="sd">                calculated first.</span>

<span class="sd">            indices (numpy.ndarray): None or a numpy.ndarray of</span>
<span class="sd">                relevant indices; that is, the indices for points</span>
<span class="sd">                where the light curve duration should be calculated.</span>

<span class="sd">        Returns:</span>

<span class="sd">            (dict): a dictionary with keys `peak` (the peak flux),</span>
<span class="sd">                `ipeak` (the index of the light curve for the peak</span>
<span class="sd">                flux), `increase` (a dictionary of flux increase</span>
<span class="sd">                values, the two keys indicated the `absolute` and</span>
<span class="sd">                `relative` flux increase).</span>

<span class="sd">        In case of several local maxima (multiple outbursts), only the</span>
<span class="sd">        peak flux and increase/decrease for the outburst in which the</span>
<span class="sd">        peak flux falls is calculated.</span>

<span class="sd">        The peak flux can be *negative* (eg, occultation transient), in</span>
<span class="sd">        which case increase becomes negative.</span>

<span class="sd">        If all indices are True, then the source is still at its</span>
<span class="sd">        background level, and no clear transient exists: ipeak will</span>
<span class="sd">        be None, increase is an empty dict and peakflux is 0.0.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">background</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calc_background</span><span class="p">()</span>
            <span class="n">background</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">background</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxincrease</span>
        <span class="n">increase</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fluxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span>
        <span class="n">ipeak</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fluxes</span> <span class="o">-</span> <span class="n">background</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="n">peakflux</span> <span class="o">=</span> <span class="n">fluxes</span><span class="p">[</span><span class="n">ipeak</span><span class="p">]</span>
        <span class="n">increase</span><span class="p">[</span><span class="s">&#39;absolute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakflux</span> <span class="o">-</span> <span class="n">background</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">]</span>
        <span class="n">increase</span><span class="p">[</span><span class="s">&#39;relative&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakflux</span> <span class="o">/</span> <span class="n">background</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxincrease</span><span class="p">[</span><span class="s">&#39;increase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">increase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxincrease</span><span class="p">[</span><span class="s">&#39;peak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakflux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxincrease</span><span class="p">[</span><span class="s">&#39;ipeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipeak</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxincrease</span>

</div>
<div class="viewcode-block" id="LightCurve.calc_risefall"><a class="viewcode-back" href="../../../../devref/tkp/classification/features/lightcurve.html#tkp.classification.features.lightcurve.LightCurve.calc_risefall">[docs]</a>    <span class="k">def</span> <span class="nf">calc_risefall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ipeak</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the (total) flux increase &amp; decrease</span>

<span class="sd">        Kwargs:</span>

<span class="sd">            background (float): previously calculated background (or</span>
<span class="sd">                given by the user). If not given, the background is</span>
<span class="sd">                calculated first.</span>

<span class="sd">            indices (numpy.ndarray): None or a numpy.ndarray of</span>
<span class="sd">                relevant indices; that is, the indices for points</span>
<span class="sd">                where the light curve duration should be calculated.</span>

<span class="sd">            ipeak: the index of the light curve maximum. If not set,</span>
<span class="sd">            calculated by `calc_fluxincrease`.</span>

<span class="sd">        Returns:</span>

<span class="sd">            (3-tuple):</span>

<span class="sd">                - the first two elements are themselves two-tuples</span>
<span class="sd">                  that contain the flux increase or decrease (first element)</span>
<span class="sd">                  and the time interval (second element).</span>

<span class="sd">                - the third element is a number that indicates</span>
<span class="sd">                  the ratio between the increase and decrease.</span>
<span class="sd">                  The number is zero if the increase or decrease</span>
<span class="sd">                  could not be calculated.</span>


<span class="sd">        This method calculated the flux increase and decrease, as well</span>
<span class="sd">        as the time interval over which the flux increases or</span>
<span class="sd">        decreases.</span>

<span class="sd">        Note: when values are not available (mostly when the light</span>
<span class="sd">        curve hasn&#39;t yet returned to background), they will be set to</span>
<span class="sd">        0. This is an integer, and one could use this to see if this is</span>
<span class="sd">        a calculated value or a indication of a non-available value, while</span>
<span class="sd">        it is still compatible with (calculated) float values, in contrast</span>
<span class="sd">        to eg None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">background</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calc_background</span><span class="p">()</span>
            <span class="n">background</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">background</span>
        <span class="k">if</span> <span class="n">ipeak</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxincrease</span><span class="p">[</span><span class="s">&#39;ipeak&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calc_fluxincrease</span><span class="p">()</span>
            <span class="n">ipeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxincrease</span><span class="p">[</span><span class="s">&#39;ipeak&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">background</span><span class="p">[</span><span class="s">&#39;indices&#39;</span><span class="p">]</span>
        <span class="c"># If we don&#39;t have a clear transient, don&#39;t try and calculate nonsense</span>
        <span class="k">if</span> <span class="n">ipeak</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">indices</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">risefall</span>

        <span class="n">deltaflux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">[</span><span class="n">ipeak</span><span class="p">]</span> <span class="o">-</span> <span class="n">background</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">]</span>
        <span class="n">ibackground</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># calculate duration of fall</span>
        <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>  <span class="c"># type(numpy.bool) is not bool; can&#39;t use &#39;is&#39;!</span>
            <span class="c"># light curve hasn&#39;t yet returned to background</span>
            <span class="n">fall</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;flux&#39;</span><span class="p">:</span> <span class="n">deltaflux</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># find first index when returned background for outburst around ipeak</span>
            <span class="n">iback</span> <span class="o">=</span> <span class="n">ibackground</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibackground</span> <span class="o">&gt;</span> <span class="n">ipeak</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">delta_tfall</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span><span class="p">[</span><span class="n">iback</span><span class="p">]</span> <span class="o">+</span>
                            <span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">[</span><span class="n">iback</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span>
                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span><span class="p">[</span><span class="n">ipeak</span><span class="p">]</span> <span class="o">+</span>
                            <span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">[</span><span class="n">ipeak</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="n">delta_tfall</span> <span class="o">=</span> <span class="n">delta_tfall</span><span class="o">.</span><span class="n">days</span> <span class="o">*</span> <span class="n">SECONDS_IN_DAY</span> <span class="o">+</span> <span class="n">delta_tfall</span><span class="o">.</span><span class="n">seconds</span>
            <span class="n">fall</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">:</span> <span class="n">delta_tfall</span><span class="p">,</span> <span class="s">&#39;flux&#39;</span><span class="p">:</span> <span class="n">deltaflux</span><span class="p">}</span>

        <span class="c"># calculate duration of rise</span>
        <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>  <span class="c"># type(numpy.bool) is not bool; can&#39;t use &#39;is&#39;!</span>
            <span class="c"># light curve started above background already</span>
            <span class="n">rise</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;flux&#39;</span><span class="p">:</span> <span class="n">deltaflux</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># find last index before rise for outburst around ipeak</span>
            <span class="n">iback</span> <span class="o">=</span> <span class="n">ibackground</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibackground</span><span class="o">&lt;</span><span class="n">ipeak</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">delta_trise</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span><span class="p">[</span><span class="n">ipeak</span><span class="p">]</span> <span class="o">+</span>
                            <span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">[</span><span class="n">ipeak</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span>
                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taustart_tss</span><span class="p">[</span><span class="n">iback</span><span class="p">]</span> <span class="o">+</span>
                            <span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_times</span><span class="p">[</span><span class="n">iback</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="n">delta_trise</span> <span class="o">=</span> <span class="n">delta_trise</span><span class="o">.</span><span class="n">days</span> <span class="o">*</span> <span class="n">SECONDS_IN_DAY</span> <span class="o">+</span> <span class="n">delta_trise</span><span class="o">.</span><span class="n">seconds</span>
            <span class="n">rise</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">:</span> <span class="n">delta_trise</span><span class="p">,</span> <span class="s">&#39;flux&#39;</span><span class="p">:</span> <span class="n">deltaflux</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">rise</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fall</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># calculate rise to fall ratio</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">rise</span><span class="p">[</span><span class="s">&#39;flux&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">rise</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">])</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">fall</span><span class="p">[</span><span class="s">&#39;flux&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">fall</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">risefall</span><span class="p">[</span><span class="s">&#39;rise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">risefall</span><span class="p">[</span><span class="s">&#39;fall&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">risefall</span><span class="p">[</span><span class="s">&#39;ratio&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">risefall</span>

</div>
<div class="viewcode-block" id="LightCurve.calc_stats"><a class="viewcode-back" href="../../../../devref/tkp/classification/features/lightcurve.html#tkp.classification.features.lightcurve.LightCurve.calc_stats">[docs]</a>    <span class="k">def</span> <span class="nf">calc_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate some standard statistics.</span>

<span class="sd">        Kwargs:</span>

<span class="sd">            indices (numpy.ndarray of bool): specific selection of data to</span>
<span class="sd">                use for calculations</span>

<span class="sd">        Returns:</span>

<span class="sd">            (dict): statistics of the *full* light curve (ie, including</span>
<span class="sd">                background parts): mean, standard deviation, skew,</span>
<span class="sd">                kurtosis. All calculated values are weighted by the flux</span>
<span class="sd">                errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="c"># prevent calcuation on empty light curves</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">indices</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="c">#self.stats[&#39;wmean&#39;] = pygsl.statistics.wmean(weights, self.fluxes[indices])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s">&#39;median&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="c">#self.stats[&#39;wstddev&#39;] = pygsl.statistics.wsd_m(</span>
        <span class="c">#    weights, self.fluxes[indices], self.stats[&#39;wmean&#39;])</span>
        <span class="c">#self.stats[&#39;wskew&#39;] = pygsl.statistics.wskew_m_sd(</span>
        <span class="c">#    weights, self.fluxes[indices], self.stats[&#39;wmean&#39;], self.stats[&#39;wstddev&#39;])</span>
        <span class="c">#self.stats[&#39;wkurtosis&#39;] = pygsl.statistics.wkurtosis_m_sd(</span>
        <span class="c">#    weights, self.fluxes[indices], self.stats[&#39;wmean&#39;], self.stats[&#39;wstddev&#39;])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/lofar.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">LOFAR Transients Pipeline 1.1 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, LOFAR Transients Key Project.
    </div>
  </body>
</html>